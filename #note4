202184032 안신영

dezero에서 구현한 함수들 → add, mul, div, sin 등등 입력과 출력이 모두 스칼라라고 가정함

x는 단일값인 스칼라(0차원의 ndarray 인스턴스)

import numpy as np

import dezero.functions as F

from dezero import Variable

x = Variable(np.array(1.0))

y = F.sin(x)

print(y)

- 텐서 처리
    
    x 가 텐서일 경우 - sin 함수가 원소별로 적용된다.
    
    입력과 출력 텐서의 형상은 바뀌지 않는다 
    

x = Variable(np.array([[1, 2, 3], [4, 5, 6]]))

y = F.sin(x)

print(y)

텐서 사용 시의 역전파

- 구현한 함수들이 텐서를 이용해 계산해도 역전파 코드가 문제없이 동작을 하는데 스칼라를 대상으로 역전파를 구현한다.
- dezero 함수에 텐서를 건네면 첸서의 원소마다 스칼라로 계산함
- 텐서 원소별 스칼라 계산이 이루어지면, 스칼라를 가정해 구현한 역전파는 텐서의 원소별 계산에서도 성립한다.

7주차 전까지 사용한 함수들이 스칼라라고 한다면 어떤 것이 텐서인지 정확히 잘 모르겠다. 코드를 보았을 때도 어떤 차이점을 보이는지 모르겠음. 

마지막 출력이 스칼라인 계산 그래프에 대한 역전파

- y.backward(retain_grad=True)를 실행하면 각 변수의 미분 값이 구해짐
- 기울기의 형상과 순전파 때의 데이터 형상이 일치
    
    x.shape == x.grad.shape
    

텐서를 사용한 계산에서의 역전파

- 입출력 데이터가 스칼라라고 가정하고, 순전파와 역전파 구현 가능
- 텐서 입력해도 역전파 성립

원소별로 계산하지 않는 함수

- 텐서의 형상을 변환하는 reshape 함수
- 행렬 전치하는 transpose 함수
- 두 함수 모두 텐서의 형상을 바꾸는 함수

reshape 함수 → 텐서의 형상을 변환, 원소 수는 같고 형상만 변환

x = np.array([[1, 2, 3], [4, 5, 6]])

y = np.reshape(x, (6, ))

print(y)

이 코드에서 x의 형상을 (2, 3)에서 (6, )으로 변환한다는 코드이다.

reshape 함수는 구체적인 계산을 하지않는다. 

dezero용 reshape 함수 구현

- Reshape 클래스를 초기화할 때 변형 목표가 되는 형상을 shape 인수로 받음
- 순전파시에 넘파이의 reshape 함수를 사용하여 형상을 변환

self.x_shape → 역전파에서 입력 형상 변환 가능

구현한 reshape 함수 사용

- y.backward(retain_grad = True)를 수행하여 x의 기울기를 구할 수 있음 → y의 기울기도 자동으로 채워짐
- 원소는 모두 1로 이루어진 텐서

행렬의 전치 → transpose 함수

텐서의 원소 자체는 그대로이고 형상만 바뀜

텐서라는 것이 변수 안에 들어가있는 함수들인데 그것들이 형상이 바뀌는 것인지 안바뀌는 것인지를 나타내는 것인가?

행렬의 전치는 역전파에서는 순전파와는 반대의 변환이 이루어진다.

두번째에서는 @property 데코레이터가 붙어 인스턴스 변수로 사용

sum 함수의 역전파
- 벡터에 sum함수를 적용하면 스칼라 출력
- 역전파는 출력 쪽에서 준해준 값인 1을 [1, 1] 이라는 벡터로 확장해전파

원소가 2개 이상이 ㄴ벡터의 합에 대한 역전파
- 기울기 벡터읭 원소 수만큼 복사하면 됨
broadcast_to 함수를 사용하여 입력 변수와 형상이 같아지도록 기울기 gy의 원소를 복사함
행렬을 입력하여 벡터가 아닌 경우의 동작을 확인한다

axis와 keepdims
axis - 축 지정 인수(합계를 구할 때 축을 지정할 수 있음)
keepdims 인수 입력과 출력의 차원 수를 똑같게 유지할지 정하는 플래그
Sum클래스를 초기화할 때 axis와 keepdims를 입력받아 속성으로 설정
순전파에서 이 속성들을 사용해 합계를 구한다
역전파시 broadcast_to 함수를 하용하여 입력 변수의 형상과 같아지도록 기울기 원소를 복사한다.

np.broadcast_to 함수의 역전파
- 입력 x의 형상과 같아지도록 기울기 합과 구함
sum_to(x, shape)함수가 있으면 간단하게 해견된다.

브로드 캐스트 대응
- 형상이 다른 다차원 배열끼리의 연산을 가능하게 하는 넘파이 기능
sum_to 함수를 구현한 이유는 넘파이 브로드캐스트에 대응하기 위함이다. 

브로드캐스트 역전파 계산
class Add(Function):
    def forward(self, x0, x1):
        self.x0_shape, self.x1_shape = x0.shape, x1.shape
        y = x0 + x1
        return y

    def backward(self, gy):
        gx0, gx1 = gy, gy
        if self.x0_shape ! =self.x1_shape:
            gx0 = dezero.functions.sum_sumto(gx0, self.x0_shape)
            gx1 = dezero.functions.sum_sumto(gx1, self.x1_shape)
        return gx0, gx1

행렬과 벡터를 사용한 계산 시 체크할 점
- shape(형상)에 주의 
- 원소 수가 일치


8주차

머신러닝의 본질은 데이터를 사용하여 문제를 해결하고, 모아진 데이터로부터 컴퓨터가 스스로 해법을 찾아내는 것이다. 
이를 위해 DeZero를 사용하여 머신러닝 문제를 해결하는데, 이번에는 선형 회귀를 구현하는 단계를 나타낸다.

토이 데이터셋은 실험용으로 만든 작은 데이터셋으로, 선형 관계가 있으며 노이즈로 인해 점들이 퍼져 있다. 
이 데이터셋을 사용하여 주어진 데이터를 잘 표현하는 함수를 찾고자 하는데, 이를 위해 선형 관계를 표현하는 식을 설정하고, 평균 제곱 오차를 최소화하여 학습을 진행한다.

학습은 경사하강법을 사용하여 손실 함수의 출력을 최소화하는 매개변수를 찾는 것으로 이루어진다.
이때 중간에 등장하는 변수들은 메모리를 많이 차지하므로, 메모리 최적화를 위해 개선이 필요하다.
이를 위해 DeZero의 함수를 개선하여 메모리를 더 효율적으로 사용하는 방법을 도입한다.

또한, 선형 회귀를 신경망으로 확장하여 비선형 데이터셋에 대한 문제를 해결한다.
활성화 함수를 이용하여 비선형 변환을 수행하고, 다층 신경망을 구현하여 복잡한 문제에 대응한다.
이를 위해 Layer 클래스와 Parameter 클래스를 사용하여 매개변수를 효율적으로 관리한다.

최종적으로는 완전연결계층 신경망을 구현하여 다양한 문제에 적용할 수 있는 모델을 만들게 된다.
이를 통해 DeZero를 사용하여 신경망을 효율적으로 구현하고, 다양한 머신러닝 문제에 대응할 수 있게 된다.





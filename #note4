202184032 안신영

dezero에서 구현한 함수들 → add, mul, div, sin 등등 입력과 출력이 모두 스칼라라고 가정함

x는 단일값인 스칼라(0차원의 ndarray 인스턴스)

import numpy as np

import dezero.functions as F

from dezero import Variable

x = Variable(np.array(1.0))

y = F.sin(x)

print(y)

- 텐서 처리
    
    x 가 텐서일 경우 - sin 함수가 원소별로 적용된다.
    
    입력과 출력 텐서의 형상은 바뀌지 않는다 
    

x = Variable(np.array([[1, 2, 3], [4, 5, 6]]))

y = F.sin(x)

print(y)

텐서 사용 시의 역전파

- 구현한 함수들이 텐서를 이용해 계산해도 역전파 코드가 문제없이 동작을 하는데 스칼라를 대상으로 역전파를 구현한다.
- dezero 함수에 텐서를 건네면 첸서의 원소마다 스칼라로 계산함
- 텐서 원소별 스칼라 계산이 이루어지면, 스칼라를 가정해 구현한 역전파는 텐서의 원소별 계산에서도 성립한다.

7주차 전까지 사용한 함수들이 스칼라라고 한다면 어떤 것이 텐서인지 정확히 잘 모르겠다. 코드를 보았을 때도 어떤 차이점을 보이는지 모르겠음. 

마지막 출력이 스칼라인 계산 그래프에 대한 역전파

- y.backward(retain_grad=True)를 실행하면 각 변수의 미분 값이 구해짐
- 기울기의 형상과 순전파 때의 데이터 형상이 일치
    
    x.shape == x.grad.shape
    

텐서를 사용한 계산에서의 역전파

- 입출력 데이터가 스칼라라고 가정하고, 순전파와 역전파 구현 가능
- 텐서 입력해도 역전파 성립

원소별로 계산하지 않는 함수

- 텐서의 형상을 변환하는 reshape 함수
- 행렬 전치하는 transpose 함수
- 두 함수 모두 텐서의 형상을 바꾸는 함수

reshape 함수 → 텐서의 형상을 변환, 원소 수는 같고 형상만 변환

x = np.array([[1, 2, 3], [4, 5, 6]])

y = np.reshape(x, (6, ))

print(y)

이 코드에서 x의 형상을 (2, 3)에서 (6, )으로 변환한다는 코드이다.

reshape 함수는 구체적인 계산을 하지않는다. 

dezero용 reshape 함수 구현

- Reshape 클래스를 초기화할 때 변형 목표가 되는 형상을 shape 인수로 받음
- 순전파시에 넘파이의 reshape 함수를 사용하여 형상을 변환

self.x_shape → 역전파에서 입력 형상 변환 가능

구현한 reshape 함수 사용

- y.backward(retain_grad = True)를 수행하여 x의 기울기를 구할 수 있음 → y의 기울기도 자동으로 채워짐
- 원소는 모두 1로 이루어진 텐서

행렬의 전치 → transpose 함수

텐서의 원소 자체는 그대로이고 형상만 바뀜

텐서라는 것이 변수 안에 들어가있는 함수들인데 그것들이 형상이 바뀌는 것인지 안바뀌는 것인지를 나타내는 것인가?

행렬의 전치는 역전파에서는 순전파와는 반대의 변환이 이루어진다.

두번째에서는 @property 데코레이터가 붙어 인스턴스 변수로 사용
